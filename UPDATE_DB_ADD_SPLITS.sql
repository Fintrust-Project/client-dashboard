
-- Create Payment Splits table to handle splitting commissions
create table if not exists public.payment_splits (
  id bigint generated by default as identity primary key,
  payment_id bigint references public.payments(id) on delete cascade,
  user_id uuid references public.profiles(id),
  percentage numeric not null check (percentage > 0 and percentage <= 100),
  amount numeric not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- RLS Policies for Payment Splits
alter table public.payment_splits enable row level security;

-- Admin can manage all splits
drop policy if exists "Admin manage all splits" on public.payment_splits;
create policy "Admin manage all splits" on public.payment_splits for all using (
  exists (select 1 from public.profiles where id = auth.uid() and role = 'admin')
);

-- Users can view splits where they are the beneficiary OR where they own the parent payment
drop policy if exists "Users view relevant splits" on public.payment_splits;
create policy "Users view relevant splits" on public.payment_splits for select using (
  user_id = auth.uid() or exists (
    select 1 from public.payments where id = public.payment_splits.payment_id and user_id = auth.uid()
  )
);

-- Users can insert splits only if they own the parent payment (checked via frontend logic but RLS allows insert if payment belongs to them... wait, RLS on insert is tricky with foreign keys)
-- A cleaner RLS for insert:
drop policy if exists "Users insert splits for own payments" on public.payment_splits;
create policy "Users insert splits for own payments" on public.payment_splits for insert with check (
   exists (select 1 from public.payments where id = payment_id and user_id = auth.uid()) OR
   exists (select 1 from public.profiles where id = auth.uid() and role = 'admin')
);
